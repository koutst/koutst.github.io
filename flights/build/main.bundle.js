/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = "\n\n(function(){\n\n\n  var margin = { top: 0, left: 0, right: 0, down: 0},\n    height = 750 - margin.top - margin.down,\n    width = 2000 - margin.left - margin.right;\n\n  var zoom = d3.zoom()\n    .scaleExtent([1, 8])\n    .on(\"zoom\", zoomed);\n//\n/***** ALL MATH FUNCTIONS ****/\n\nvar toRad = Math.PI / 180;\nvar toDeg = 180 / Math.PI;\n\n\n// Helper function: cross product of two vectors v0&v1\nfunction cross(v0, v1) {\n    return [v0[1] * v1[2] - v0[2] * v1[1], v0[2] * v1[0] - v0[0] * v1[2], v0[0] * v1[1] - v0[1] * v1[0]];\n}\n\n//Helper function: dot product of two vectors v0&v1\nfunction dot(v0, v1) {\n    for (var i = 0, sum = 0; v0.length > i; ++i) sum += v0[i] * v1[i];\n    return sum;\n}\n\n// Helper function:\n// This function converts a [lon, lat] coordinates into a [x,y,z] coordinate\n// the [x, y, z] is Cartesian, with origin at lon/lat (0,0) center of the earth\nfunction lonlat2xyz( coord ){\n\n\tvar lon = coord[0] * toRad;\n\tvar lat = coord[1] * toRad;\n\n\tvar x = Math.cos(lat) * Math.cos(lon);\n\n\tvar y = Math.cos(lat) * Math.sin(lon);\n\n\tvar z = Math.sin(lat);\n\n\treturn [x, y, z];\n}\n\n// Helper function:\n// This function computes a quaternion representation for the rotation between to vectors\n// https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions#Euler_angles_.E2.86.94_Quaternion\nfunction quaternion(v0, v1) {\n\n\tif (v0 && v1) {\n\n\t    var w = cross(v0, v1),  // vector pendicular to v0 & v1\n\t        w_len = Math.sqrt(dot(w, w)); // length of w\n\n        if (w_len == 0)\n        \treturn;\n\n        var theta = .5 * Math.acos(Math.max(-1, Math.min(1, dot(v0, v1))));\n\n\t       let qi  = w[2] * Math.sin(theta) / w_len;\n\t      let  qj  = - w[1] * Math.sin(theta) / w_len;\n\t       let qk  = w[0]* Math.sin(theta) / w_len;\n\t      let  qr  = Math.cos(theta);\n\n\t    return theta && [qr, qi, qj, qk];\n\t}\n}\n\n// Helper function:\n// This functions converts euler angles to quaternion\n// https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions#Euler_angles_.E2.86.94_Quaternion\nfunction euler2quat(e) {\n\n\tif(!e) return;\n\n    var roll = .5 * e[0] * toRad,\n        pitch = .5 * e[1] * toRad,\n        yaw = .5 * e[2] * toRad,\n\n        sr = Math.sin(roll),\n        cr = Math.cos(roll),\n        sp = Math.sin(pitch),\n        cp = Math.cos(pitch),\n        sy = Math.sin(yaw),\n        cy = Math.cos(yaw),\n\n        qi = sr*cp*cy - cr*sp*sy,\n        qj = cr*sp*cy + sr*cp*sy,\n        qk = cr*cp*sy - sr*sp*cy,\n        qr = cr*cp*cy + sr*sp*sy;\n\n    return [qr, qi, qj, qk];\n}\n\n// This functions computes a quaternion multiply\n// Geometrically, it means combining two quant rotations\n// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/arithmetic/index.htm\nfunction quatMultiply(q1, q2) {\n\tif(!q1 || !q2) return;\n\n    var a = q1[0],\n        b = q1[1],\n        c = q1[2],\n        d = q1[3],\n        e = q2[0],\n        f = q2[1],\n        g = q2[2],\n        h = q2[3];\n\n    return [\n     a*e - b*f - c*g - d*h,\n     b*e + a*f + c*h - d*g,\n     a*g - b*h + c*e + d*f,\n     a*h + b*g - c*f + d*e];\n\n}\n\n// This function computes quaternion to euler angles\n// https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions#Euler_angles_.E2.86.94_Quaternion\nfunction quat2euler(t){\n\n\tif(!t) return;\n\n\treturn [ Math.atan2(2 * (t[0] * t[1] + t[2] * t[3]), 1 - 2 * (t[1] * t[1] + t[2] * t[2])) * toDeg,\n\t\t\t Math.asin(Math.max(-1, Math.min(1, 2 * (t[0] * t[2] - t[3] * t[1])))) * toDeg,\n\t\t\t Math.atan2(2 * (t[0] * t[3] + t[1] * t[2]), 1 - 2 * (t[2] * t[2] + t[3] * t[3])) * toDeg\n\t\t\t]\n}\n\n/*  This function computes the euler angles when given two vectors, and a rotation\n\tThis is really the only math function called with d3 code.\n\n\tv0 - starting pos in lon/lat, commonly obtained by projection.invert\n\tv1 - ending pos in lon/lat, commonly obtained by projection.invert\n\to0 - the projection rotation in euler angles at starting pos (v0), commonly obtained by projection.rotate\n*/\n\nfunction eulerAngles(v0, v1, o0) {\n\n\t/*\n\t\tThe math behind this:\n\t\t- first calculate the quaternion rotation between the two vectors, v0 & v1\n\t\t- then multiply this rotation onto the original rotation at v0\n\t\t- finally convert the resulted quat angle back to euler angles for d3 to rotate\n\t*/\n\n\tvar t = quatMultiply( euler2quat(o0), quaternion(lonlat2xyz(v0), lonlat2xyz(v1) ) );\n\treturn quat2euler(t);\n}\n\n\n/**************end of math functions**********************/\n  var drag = d3.drag()\n                .on(\"start\", dragstart)\n                .on(\"drag\", dragged)\n                .on(\"end\", dragend)\n\n  var gpos0, o0;\n\n  function dragstart(){\n  \tgpos0 = projection.invert(d3.mouse(this));\n  \to0 = projection.rotate();\n\n    debugger\n  \tsvg.insert(\"path\")\n               .datum({type: \"Point\", coordinates: gpos0})\n               .attr(\"class\", \"point\")\n               .attr(\"d\", path);\n  }\n\n  function dragged(){\n\n  \tvar gpos1 = projection.invert(d3.mouse(this));\n\n  \to0 = projection.rotate();\n\n  \tvar o1 = eulerAngles(gpos0, gpos1, o0);\n  \tprojection.rotate(o1);\n\n  \tsvg.selectAll(\".point\")\n  \t \t\t.datum({type: \"Point\", coordinates: gpos1});\n    svg.selectAll(\"path\").attr(\"d\", path);\n\n  }\n\n  function dragend(){\n  \tsvg.selectAll(\".point\").remove();\n  }\n//\n\n\n  let svg = d3.select(\"#map\")\n              .append(\"svg\")\n              .attr(\"height\", height + margin.top + margin.down)\n              .attr(\"width\", width + margin.left + margin.right)\n\n\n  let rectSVG = svg.append(\"pattern\")\n                    .attr(\"class\", \"rect-svg\")\n                    .attr(\"height\", height + margin.top + margin.down)\n                    .attr(\"width\", width + margin.left + margin.right)\n\n\n  let gMap = svg.append(\"g\")\n                .attr(\"class\", \"g-map\")\n                .attr(\"transform\", \"translate(\"+ margin.left + \",\" + margin.top +\")\")\n  //\n  // function startDrag(d){\n  //   d3.select(this).\n  // }\n\n  let rectGMap = gMap.append(\"rect\")\n                .attr(\"class\", \"rect-g-map\")\n                .attr(\"height\", 1250)\n                .attr(\"width\", width + margin.left + margin.right)\n                .attr(\"transform\", \"translate(\"+ margin.left + \",\" + -400 +\")\")\n\n  let projection = d3.geoOrthographic()\n                .translate([ width / 2, height / 2 ])\n                .rotate([100, 350, 7])\n                .scale(250);\n\n  let rectZoom = svg.append(\"rect\")\n                .data([projection])\n                .attr(\"class\", \"rect-zoom\")\n                .attr(\"height\", height + margin.top + margin.down)\n                .attr(\"width\", width + margin.left + margin.right)\n                .style(\"fill\", \"none\")\n                .style(\"pointer-events\", \"all\")\n                .call(drag)\n                .call(zoom)\n                // .call(zoom)\n                  // .on(\"mousedown.zoom\", function(d){\n                  //   // debugger\n                  //   // d.rotate([50, 0, 0])\n                  // })\n                  // .on(\"touchstart.zoom\", null)\n                  // .on(\"touchmove.zoom\", null)\n                  // .on(\"touchend.zoom\", null);\n\n\n    function zoomed() {\n      gMap.attr(\"transform\", d3.event.transform );\n    }\n\n    d3.queue()\n      .defer(d3.json, \"countries.topojson\")\n      .defer(d3.json, \"airports.topojson\")\n      .defer(d3.csv, \"flights.csv\")\n      .await(ready);\n\n\n\n\n\n    var path = d3.geoPath()\n      .projection(projection);\n\n    let intSpeed = 100\n\n\n    function ready(error, countriesData, airportsData, flightData) {\n      // console.log(flightData)\n      var countriesParsed = topojson.feature(countriesData, countriesData.objects.countries).features;\n\n      gMap.selectAll(\".country\")\n        .data(countriesParsed)\n        .enter()\n        .append(\"path\")\n        .attr(\"class\", \"country\")\n        .attr(\"d\", path)\n        .on(\"mouseover\", function(d){\n          d3.select(this)\n          .attr(\"class\", \"activeCountry\")\n          .attr(\"fill\", \"black\");\n\n          d3.select(\".map\")\n          .append(\"text\")\n          .attr(\"class\", \"countrydetails\")\n          .text(\n            \"Country: \" + d.properties.NAME\n          )\n          d3.select(\".map\")\n          .append(\"text\")\n          .attr(\"class\", \"countrydetails\")\n          .text(\n            \"Continent: \" + d.properties.CONTINENT\n          )\n          d3.select(\".map\")\n          .append(\"text\")\n          .attr(\"class\", \"countrydetails\")\n          .text(\n            \"GDP (in millions): \" + d.properties.GDP_MD_EST\n          )\n        })\n        .on(\"mouseout\", function(d){\n          d3.selectAll(\"text.countrydetails\").remove()\n          d3.selectAll(\".activeCountry\")\n          .attr(\"class\", \"country\")\n        });\n\n\n\n\n      let airports = topojson.feature(airportsData, airportsData.objects.airports).features;\n\n\n      let airportsNameCoord = {};\n\n      for (var i = 0; i < airports.length; i++) {\n        let iata = airports[i].properties.iata_code;\n        let coord = airports[i].geometry.coordinates\n        airportsNameCoord[iata] = {coord: coord}\n      }\n\n      let flights = [];\n      for (var i = 0; i < flightData.length; i++) {\n        let orgAir = flightData[i][\"ORIGIN\"];\n        let destAir = flightData[i][\"DEST\"];\n        let depTime = flightData[i][\"DEP_TIME\"]\n        if (airportsNameCoord[orgAir] && airportsNameCoord[destAir] && depTime) {\n          flightData[i][\"type\"] = \"Point\";\n          flightData[i][\"coordinates\"] = airportsNameCoord[orgAir][\"coord\"];\n          flightData[i][\"DESTCOORD\"] = airportsNameCoord[destAir][\"coord\"];\n          flights.push(flightData[i])\n        }\n      }\n\n      function transition(plane, route) {\n        let l = route.node().getTotalLength();\n        plane.attr('opacity', 1)\n              .transition()\n              .duration(10*route.node().getTotalLength())\n              .attrTween(\"transform\", translateAttr(route.node()))\n              .attr(\"d\", path)\n              .remove()\n        ;\n      }\n\n      function translateAttr(path) {\n        var l = path.getTotalLength();\n        return function(d, i, a) {\n          return function(t) {\n            var p = path.getPointAtLength(t * l);\n            var po = path.getPointAtLength(0);\n            return \"translate(\" + (p.x-po.x) + \",\" + (p.y-po.y) + \")\";\n          };\n        };\n      }\n\n      let timer = 0;\n\n      const interval = function(){\n        //\n        gMap.selectAll(\".clock\").remove();\n        let minutes = timer%100;\n        let hours = (timer-minutes)/100;\n        if (hours < 10 && minutes < 10) {\n          gMap.append(\"text\")\n          .attr(\"class\", \"clock\")\n          .text(\"Time (hh/mm): 0\" +hours + \":0\" + minutes );\n\n        }else if (hours < 10) {\n          gMap.append(\"text\")\n          .attr(\"class\", \"clock\")\n          .text(\"Time (hh/mm): 0\" +hours + \":\" + minutes )\n        } else if (minutes < 10) {\n          gMap.append(\"text\")\n          .attr(\"class\", \"clock\")\n          .text(\"Time (hh/mm): \" +hours + \":0\" + minutes )\n        } else {\n          gMap.append(\"text\")\n          .attr(\"class\", \"clock\")\n          .text(\"Time (hh/mm): \" +hours + \":\" + minutes )\n        }\n        gMap.selectAll(\".clock\")\n        .attr(\"height\", 0)\n        .attr(\"width\", 10)\n\n        for (var i = 0; i < flights.length-1; i++) {\n          // let currFlight = {coordinates: flights[i][\"coordinates\"]}\n          let currFlight = Object.assign({}, flights[i])\n          // delete currFlight[\"DESTCOORD\"]\n          if (parseInt(flights[i].DEP_TIME) === timer) {\n            transition(\n              gMap.datum(currFlight)\n                  .append(\"path\")\n                  .attr(\"class\", \"plane\")\n                  .attr(\"fill\", \"red\")\n                  .attr(\"d\", path)\n                  .attr(\"stroke-width\", 0.5)\n              ,\n              gMap.datum({type: \"LineString\", coordinates: [flights[i].coordinates, flights[i].DESTCOORD]})\n                  .append(\"path\")\n                  .attr(\"class\", \"route\")\n                  .attr(\"d\", path)\n                  .attr('opacity', 0.5)\n                  .attr('fill', \"none\")\n                  .attr('stroke-width', 0.01)\n                  .attr('stroke', '\t#00FF00')\n                  .transition()\n                  .duration(1000)\n                  .remove());\n          }\n\n        }\n        timer += 1\n        if (timer%100 >= 60) {\n          timer += 100 - timer%100\n        }\n        if (timer >= 2400) {\n          timer = 0;\n        }\n      }\n\n\n      let time = setInterval(\n        interval, intSpeed)\n\n      gMap.selectAll(\".airport\")\n      .data(airports)\n      .enter()\n      .append(\"path\")\n      .attr(\"class\", \"airport\")\n      .attr(\"d\", path.pointRadius(1.5))\n      // .attr(\"scale\", 100)\n      .on(\"mouseover\", function(d){\n        //\n        d3.select(this)\n        .attr(\"class\", \"activeAirport\")\n        .attr(\"stroke\", \"blue\")\n        .attr(\"stroke-width\", 0.5)\n        .attr(\"fill\", \"red\")\n        .attr(\"d\", path.pointRadius(5));\n\n        d3.select(\".map\")\n        .append(\"text\")\n        .attr(\"class\", \"countrydetails\")\n        .text(\n          \"Airport: \" + d.properties.name\n        )\n        d3.select(\".map\")\n        .append(\"text\")\n        .attr(\"class\", \"countrydetails\")\n        .text(\n          \"IATA: \" + d.properties.iata_code\n        )\n        //\n      })\n      // .on(\"click\", )\n      .on(\"mouseout\", function(d){\n        d3.selectAll(\"text.countrydetails\").remove()\n\n        d3.selectAll(\".activeAirport\")\n        .attr(\"class\", \"airport\")\n        .attr(\"d\", path.pointRadius(1.5));\n\n      });\n\n\n      d3.select(\".map\")\n      .append(\"input\")\n      .attr(\"type\",\"button\")\n      .attr(\"class\",\"pause\")\n      .attr(\"value\",\"Pause\")\n      .on(\"click\", function(){\n          clearInterval(time)\n      });\n\n      d3.select(\".map\")\n      .append(\"input\")\n      .attr(\"type\",\"button\")\n      .attr(\"class\",\"play\")\n      .attr(\"value\",\"Play\")\n      .on(\"click\", function(){\n        clearInterval(time)\n        time = setInterval(interval, intSpeed)\n      });\n\n      let speed = d3.select(\".map\")\n      .append(\"text\")\n      .attr(\"class\", \"speed\")\n      .text(\n        \"Speed: 1 hour = \" + (intSpeed/1000)*60 + \" seconds\"\n      )\n\n      d3.select(\".map\")\n      .append(\"input\")\n      .attr(\"type\",\"button\")\n      .attr(\"class\",\"play\")\n      .attr(\"value\",\"X2\")\n      .on(\"click\", function(){\n        intSpeed = intSpeed/2\n        d3.select(\".speed\").text(\n          \"Speed: 1 hour = \" + (intSpeed/1000)*60 + \" seconds\"\n        )\n        clearInterval(time)\n        time = setInterval(interval, intSpeed)\n      });\n\n      d3.select(\".map\")\n      .append(\"input\")\n      .attr(\"type\",\"button\")\n      .attr(\"class\",\"play\")\n      .attr(\"value\",\"/2\")\n      .on(\"click\", function(){\n        intSpeed = intSpeed*2\n        d3.select(\".speed\").text(\n          \"Speed: 1 hour = \" + (intSpeed/1000)*60 + \" seconds\"\n        )\n        clearInterval(time)\n        time = setInterval(interval, intSpeed)\n      });\n\n    }\n})();\n";

/***/ })
/******/ ]);
//# sourceMappingURL=main.bundle.js.map