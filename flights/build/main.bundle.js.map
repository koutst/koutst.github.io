{"version":3,"sources":["webpack:///webpack/bootstrap 85678a8b00c122e15d92","webpack:///./lib/map_visualization.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA,kCAAkC,sBAAsB,oCAAoC,+FAA+F,gFAAgF,mEAAmE,4BAA4B,sFAAsF,2GAA2G,GAAG,+EAA+E,8BAA8B,eAAe,2BAA2B,iBAAiB,GAAG,qNAAqN,iCAAiC,+BAA+B,4CAA4C,4CAA4C,4BAA4B,uBAAuB,GAAG,6PAA6P,qBAAqB,0GAA0G,6DAA6D,+EAA+E,sDAAsD,sDAAsD,mDAAmD,qCAAqC,2CAA2C,KAAK,GAAG,oNAAoN,oBAAoB,+aAA+a,gCAAgC,GAAG,kPAAkP,0BAA0B,kKAAkK,qIAAqI,KAAK,6LAA6L,oBAAoB,4SAA4S,2bAA2b,4WAA4W,yBAAyB,GAAG,uOAAuO,2BAA2B,gDAAgD,+BAA+B,mEAAmE,oCAAoC,iFAAiF,KAAK,yBAAyB,sDAAsD,iCAAiC,+CAA+C,4BAA4B,oDAAoD,oCAAoC,EAAE,gDAAgD,OAAO,yBAAyB,yCAAyC,KAAK,ypBAAypB,iCAAiC,4cAA4c,igBAAigB,4GAA4G,8JAA8J,6BAA6B,sDAAsD,OAAO,4KAA4K,uEAAuE,oGAAoG,0IAA0I,+NAA+N,iHAAiH,klBAAklB,yCAAyC,0JAA0J,EAAE,sGAAsG,uCAAuC,yBAAyB,qBAAqB,OAAO,sDAAsD,2FAA2F,aAAa,SAAS,2BAA2B,uBAAuB,uBAAuB,OAAO,iDAAiD,gDAAgD,sIAAsI,gDAAgD,kFAAkF,iFAAiF,kDAAkD,SAAS,6CAA6C,gDAAgD,sQAAsQ,SAAS,wCAAwC,wCAAwC,oCAAoC,gCAAgC,mDAAmD,gDAAgD,8EAA8E,cAAc,YAAY,SAAS,wBAAwB,sCAAsC,0DAA0D,kCAAkC,0CAA0C,2CAA2C,0IAA0I,aAAa,sBAAsB,mJAAmJ,yBAAyB,mJAAmJ,OAAO,kJAAkJ,2HAA2H,sBAAsB,OAAO,iCAAiC,yCAAyC,6CAA6C,sHAAsH,kUAAkU,kFAAkF,iZAAiZ,aAAa,aAAa,oDAAoD,+CAA+C,8BAA8B,sBAAsB,WAAW,SAAS,6TAA6T,2OAA2O,qXAAqX,kEAAkE,yLAAyL,WAAW,EAAE,iMAAiM,wCAAwC,EAAE,6LAA6L,sFAAsF,EAAE,yXAAyX,yOAAyO,EAAE,2LAA2L,yOAAyO,EAAE,SAAS,GAAG,IAAI,I","file":"main.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 85678a8b00c122e15d92","module.exports = \"\\n\\n(function(){\\n\\n\\n  var margin = { top: 0, left: 0, right: 0, down: 0},\\n    height = 750 - margin.top - margin.down,\\n    width = 2000 - margin.left - margin.right;\\n\\n  var zoom = d3.zoom()\\n    .scaleExtent([1, 8])\\n    .on(\\\"zoom\\\", zoomed);\\n//\\n/***** ALL MATH FUNCTIONS ****/\\n\\nvar toRad = Math.PI / 180;\\nvar toDeg = 180 / Math.PI;\\n\\n\\n// Helper function: cross product of two vectors v0&v1\\nfunction cross(v0, v1) {\\n    return [v0[1] * v1[2] - v0[2] * v1[1], v0[2] * v1[0] - v0[0] * v1[2], v0[0] * v1[1] - v0[1] * v1[0]];\\n}\\n\\n//Helper function: dot product of two vectors v0&v1\\nfunction dot(v0, v1) {\\n    for (var i = 0, sum = 0; v0.length > i; ++i) sum += v0[i] * v1[i];\\n    return sum;\\n}\\n\\n// Helper function:\\n// This function converts a [lon, lat] coordinates into a [x,y,z] coordinate\\n// the [x, y, z] is Cartesian, with origin at lon/lat (0,0) center of the earth\\nfunction lonlat2xyz( coord ){\\n\\n\\tvar lon = coord[0] * toRad;\\n\\tvar lat = coord[1] * toRad;\\n\\n\\tvar x = Math.cos(lat) * Math.cos(lon);\\n\\n\\tvar y = Math.cos(lat) * Math.sin(lon);\\n\\n\\tvar z = Math.sin(lat);\\n\\n\\treturn [x, y, z];\\n}\\n\\n// Helper function:\\n// This function computes a quaternion representation for the rotation between to vectors\\n// https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions#Euler_angles_.E2.86.94_Quaternion\\nfunction quaternion(v0, v1) {\\n\\n\\tif (v0 && v1) {\\n\\n\\t    var w = cross(v0, v1),  // vector pendicular to v0 & v1\\n\\t        w_len = Math.sqrt(dot(w, w)); // length of w\\n\\n        if (w_len == 0)\\n        \\treturn;\\n\\n        var theta = .5 * Math.acos(Math.max(-1, Math.min(1, dot(v0, v1))));\\n\\n\\t       let qi  = w[2] * Math.sin(theta) / w_len;\\n\\t      let  qj  = - w[1] * Math.sin(theta) / w_len;\\n\\t       let qk  = w[0]* Math.sin(theta) / w_len;\\n\\t      let  qr  = Math.cos(theta);\\n\\n\\t    return theta && [qr, qi, qj, qk];\\n\\t}\\n}\\n\\n// Helper function:\\n// This functions converts euler angles to quaternion\\n// https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions#Euler_angles_.E2.86.94_Quaternion\\nfunction euler2quat(e) {\\n\\n\\tif(!e) return;\\n\\n    var roll = .5 * e[0] * toRad,\\n        pitch = .5 * e[1] * toRad,\\n        yaw = .5 * e[2] * toRad,\\n\\n        sr = Math.sin(roll),\\n        cr = Math.cos(roll),\\n        sp = Math.sin(pitch),\\n        cp = Math.cos(pitch),\\n        sy = Math.sin(yaw),\\n        cy = Math.cos(yaw),\\n\\n        qi = sr*cp*cy - cr*sp*sy,\\n        qj = cr*sp*cy + sr*cp*sy,\\n        qk = cr*cp*sy - sr*sp*cy,\\n        qr = cr*cp*cy + sr*sp*sy;\\n\\n    return [qr, qi, qj, qk];\\n}\\n\\n// This functions computes a quaternion multiply\\n// Geometrically, it means combining two quant rotations\\n// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/arithmetic/index.htm\\nfunction quatMultiply(q1, q2) {\\n\\tif(!q1 || !q2) return;\\n\\n    var a = q1[0],\\n        b = q1[1],\\n        c = q1[2],\\n        d = q1[3],\\n        e = q2[0],\\n        f = q2[1],\\n        g = q2[2],\\n        h = q2[3];\\n\\n    return [\\n     a*e - b*f - c*g - d*h,\\n     b*e + a*f + c*h - d*g,\\n     a*g - b*h + c*e + d*f,\\n     a*h + b*g - c*f + d*e];\\n\\n}\\n\\n// This function computes quaternion to euler angles\\n// https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions#Euler_angles_.E2.86.94_Quaternion\\nfunction quat2euler(t){\\n\\n\\tif(!t) return;\\n\\n\\treturn [ Math.atan2(2 * (t[0] * t[1] + t[2] * t[3]), 1 - 2 * (t[1] * t[1] + t[2] * t[2])) * toDeg,\\n\\t\\t\\t Math.asin(Math.max(-1, Math.min(1, 2 * (t[0] * t[2] - t[3] * t[1])))) * toDeg,\\n\\t\\t\\t Math.atan2(2 * (t[0] * t[3] + t[1] * t[2]), 1 - 2 * (t[2] * t[2] + t[3] * t[3])) * toDeg\\n\\t\\t\\t]\\n}\\n\\n/*  This function computes the euler angles when given two vectors, and a rotation\\n\\tThis is really the only math function called with d3 code.\\n\\n\\tv0 - starting pos in lon/lat, commonly obtained by projection.invert\\n\\tv1 - ending pos in lon/lat, commonly obtained by projection.invert\\n\\to0 - the projection rotation in euler angles at starting pos (v0), commonly obtained by projection.rotate\\n*/\\n\\nfunction eulerAngles(v0, v1, o0) {\\n\\n\\t/*\\n\\t\\tThe math behind this:\\n\\t\\t- first calculate the quaternion rotation between the two vectors, v0 & v1\\n\\t\\t- then multiply this rotation onto the original rotation at v0\\n\\t\\t- finally convert the resulted quat angle back to euler angles for d3 to rotate\\n\\t*/\\n\\n\\tvar t = quatMultiply( euler2quat(o0), quaternion(lonlat2xyz(v0), lonlat2xyz(v1) ) );\\n\\treturn quat2euler(t);\\n}\\n\\n\\n/**************end of math functions**********************/\\n  var drag = d3.drag()\\n                .on(\\\"start\\\", dragstart)\\n                .on(\\\"drag\\\", dragged)\\n                .on(\\\"end\\\", dragend)\\n\\n  var gpos0, o0;\\n\\n  function dragstart(){\\n  \\tgpos0 = projection.invert(d3.mouse(this));\\n  \\to0 = projection.rotate();\\n\\n    debugger\\n  \\tsvg.insert(\\\"path\\\")\\n               .datum({type: \\\"Point\\\", coordinates: gpos0})\\n               .attr(\\\"class\\\", \\\"point\\\")\\n               .attr(\\\"d\\\", path);\\n  }\\n\\n  function dragged(){\\n\\n  \\tvar gpos1 = projection.invert(d3.mouse(this));\\n\\n  \\to0 = projection.rotate();\\n\\n  \\tvar o1 = eulerAngles(gpos0, gpos1, o0);\\n  \\tprojection.rotate(o1);\\n\\n  \\tsvg.selectAll(\\\".point\\\")\\n  \\t \\t\\t.datum({type: \\\"Point\\\", coordinates: gpos1});\\n    svg.selectAll(\\\"path\\\").attr(\\\"d\\\", path);\\n\\n  }\\n\\n  function dragend(){\\n  \\tsvg.selectAll(\\\".point\\\").remove();\\n  }\\n//\\n\\n\\n  let svg = d3.select(\\\"#map\\\")\\n              .append(\\\"svg\\\")\\n              .attr(\\\"height\\\", height + margin.top + margin.down)\\n              .attr(\\\"width\\\", width + margin.left + margin.right)\\n\\n\\n  let rectSVG = svg.append(\\\"pattern\\\")\\n                    .attr(\\\"class\\\", \\\"rect-svg\\\")\\n                    .attr(\\\"height\\\", height + margin.top + margin.down)\\n                    .attr(\\\"width\\\", width + margin.left + margin.right)\\n\\n\\n  let gMap = svg.append(\\\"g\\\")\\n                .attr(\\\"class\\\", \\\"g-map\\\")\\n                .attr(\\\"transform\\\", \\\"translate(\\\"+ margin.left + \\\",\\\" + margin.top +\\\")\\\")\\n  //\\n  // function startDrag(d){\\n  //   d3.select(this).\\n  // }\\n\\n  let rectGMap = gMap.append(\\\"rect\\\")\\n                .attr(\\\"class\\\", \\\"rect-g-map\\\")\\n                .attr(\\\"height\\\", 1250)\\n                .attr(\\\"width\\\", width + margin.left + margin.right)\\n                .attr(\\\"transform\\\", \\\"translate(\\\"+ margin.left + \\\",\\\" + -400 +\\\")\\\")\\n\\n  let projection = d3.geoOrthographic()\\n                .translate([ width / 2, height / 2 ])\\n                .rotate([100, 350, 7])\\n                .scale(250);\\n\\n  let rectZoom = svg.append(\\\"rect\\\")\\n                .data([projection])\\n                .attr(\\\"class\\\", \\\"rect-zoom\\\")\\n                .attr(\\\"height\\\", height + margin.top + margin.down)\\n                .attr(\\\"width\\\", width + margin.left + margin.right)\\n                .style(\\\"fill\\\", \\\"none\\\")\\n                .style(\\\"pointer-events\\\", \\\"all\\\")\\n                .call(drag)\\n                .call(zoom)\\n                // .call(zoom)\\n                  // .on(\\\"mousedown.zoom\\\", function(d){\\n                  //   // debugger\\n                  //   // d.rotate([50, 0, 0])\\n                  // })\\n                  // .on(\\\"touchstart.zoom\\\", null)\\n                  // .on(\\\"touchmove.zoom\\\", null)\\n                  // .on(\\\"touchend.zoom\\\", null);\\n\\n\\n    function zoomed() {\\n      gMap.attr(\\\"transform\\\", d3.event.transform );\\n    }\\n\\n    d3.queue()\\n      .defer(d3.json, \\\"countries.topojson\\\")\\n      .defer(d3.json, \\\"airports.topojson\\\")\\n      .defer(d3.csv, \\\"flights.csv\\\")\\n      .await(ready);\\n\\n\\n\\n\\n\\n    var path = d3.geoPath()\\n      .projection(projection);\\n\\n    let intSpeed = 100\\n\\n\\n    function ready(error, countriesData, airportsData, flightData) {\\n      // console.log(flightData)\\n      var countriesParsed = topojson.feature(countriesData, countriesData.objects.countries).features;\\n\\n      gMap.selectAll(\\\".country\\\")\\n        .data(countriesParsed)\\n        .enter()\\n        .append(\\\"path\\\")\\n        .attr(\\\"class\\\", \\\"country\\\")\\n        .attr(\\\"d\\\", path)\\n        .on(\\\"mouseover\\\", function(d){\\n          d3.select(this)\\n          .attr(\\\"class\\\", \\\"activeCountry\\\")\\n          .attr(\\\"fill\\\", \\\"black\\\");\\n\\n          d3.select(\\\".map\\\")\\n          .append(\\\"text\\\")\\n          .attr(\\\"class\\\", \\\"countrydetails\\\")\\n          .text(\\n            \\\"Country: \\\" + d.properties.NAME\\n          )\\n          d3.select(\\\".map\\\")\\n          .append(\\\"text\\\")\\n          .attr(\\\"class\\\", \\\"countrydetails\\\")\\n          .text(\\n            \\\"Continent: \\\" + d.properties.CONTINENT\\n          )\\n          d3.select(\\\".map\\\")\\n          .append(\\\"text\\\")\\n          .attr(\\\"class\\\", \\\"countrydetails\\\")\\n          .text(\\n            \\\"GDP (in millions): \\\" + d.properties.GDP_MD_EST\\n          )\\n        })\\n        .on(\\\"mouseout\\\", function(d){\\n          d3.selectAll(\\\"text.countrydetails\\\").remove()\\n          d3.selectAll(\\\".activeCountry\\\")\\n          .attr(\\\"class\\\", \\\"country\\\")\\n        });\\n\\n\\n\\n\\n      let airports = topojson.feature(airportsData, airportsData.objects.airports).features;\\n\\n\\n      let airportsNameCoord = {};\\n\\n      for (var i = 0; i < airports.length; i++) {\\n        let iata = airports[i].properties.iata_code;\\n        let coord = airports[i].geometry.coordinates\\n        airportsNameCoord[iata] = {coord: coord}\\n      }\\n\\n      let flights = [];\\n      for (var i = 0; i < flightData.length; i++) {\\n        let orgAir = flightData[i][\\\"ORIGIN\\\"];\\n        let destAir = flightData[i][\\\"DEST\\\"];\\n        let depTime = flightData[i][\\\"DEP_TIME\\\"]\\n        if (airportsNameCoord[orgAir] && airportsNameCoord[destAir] && depTime) {\\n          flightData[i][\\\"type\\\"] = \\\"Point\\\";\\n          flightData[i][\\\"coordinates\\\"] = airportsNameCoord[orgAir][\\\"coord\\\"];\\n          flightData[i][\\\"DESTCOORD\\\"] = airportsNameCoord[destAir][\\\"coord\\\"];\\n          flights.push(flightData[i])\\n        }\\n      }\\n\\n      function transition(plane, route) {\\n        let l = route.node().getTotalLength();\\n        plane.attr('opacity', 1)\\n              .transition()\\n              .duration(10*route.node().getTotalLength())\\n              .attrTween(\\\"transform\\\", translateAttr(route.node()))\\n              .attr(\\\"d\\\", path)\\n              .remove()\\n        ;\\n      }\\n\\n      function translateAttr(path) {\\n        var l = path.getTotalLength();\\n        return function(d, i, a) {\\n          return function(t) {\\n            var p = path.getPointAtLength(t * l);\\n            var po = path.getPointAtLength(0);\\n            return \\\"translate(\\\" + (p.x-po.x) + \\\",\\\" + (p.y-po.y) + \\\")\\\";\\n          };\\n        };\\n      }\\n\\n      let timer = 0;\\n\\n      const interval = function(){\\n        //\\n        gMap.selectAll(\\\".clock\\\").remove();\\n        let minutes = timer%100;\\n        let hours = (timer-minutes)/100;\\n        if (hours < 10 && minutes < 10) {\\n          gMap.append(\\\"text\\\")\\n          .attr(\\\"class\\\", \\\"clock\\\")\\n          .text(\\\"Time (hh/mm): 0\\\" +hours + \\\":0\\\" + minutes );\\n\\n        }else if (hours < 10) {\\n          gMap.append(\\\"text\\\")\\n          .attr(\\\"class\\\", \\\"clock\\\")\\n          .text(\\\"Time (hh/mm): 0\\\" +hours + \\\":\\\" + minutes )\\n        } else if (minutes < 10) {\\n          gMap.append(\\\"text\\\")\\n          .attr(\\\"class\\\", \\\"clock\\\")\\n          .text(\\\"Time (hh/mm): \\\" +hours + \\\":0\\\" + minutes )\\n        } else {\\n          gMap.append(\\\"text\\\")\\n          .attr(\\\"class\\\", \\\"clock\\\")\\n          .text(\\\"Time (hh/mm): \\\" +hours + \\\":\\\" + minutes )\\n        }\\n        gMap.selectAll(\\\".clock\\\")\\n        .attr(\\\"height\\\", 0)\\n        .attr(\\\"width\\\", 10)\\n\\n        for (var i = 0; i < flights.length-1; i++) {\\n          // let currFlight = {coordinates: flights[i][\\\"coordinates\\\"]}\\n          let currFlight = Object.assign({}, flights[i])\\n          // delete currFlight[\\\"DESTCOORD\\\"]\\n          if (parseInt(flights[i].DEP_TIME) === timer) {\\n            transition(\\n              gMap.datum(currFlight)\\n                  .append(\\\"path\\\")\\n                  .attr(\\\"class\\\", \\\"plane\\\")\\n                  .attr(\\\"fill\\\", \\\"red\\\")\\n                  .attr(\\\"d\\\", path)\\n                  .attr(\\\"stroke-width\\\", 0.5)\\n              ,\\n              gMap.datum({type: \\\"LineString\\\", coordinates: [flights[i].coordinates, flights[i].DESTCOORD]})\\n                  .append(\\\"path\\\")\\n                  .attr(\\\"class\\\", \\\"route\\\")\\n                  .attr(\\\"d\\\", path)\\n                  .attr('opacity', 0.5)\\n                  .attr('fill', \\\"none\\\")\\n                  .attr('stroke-width', 0.01)\\n                  .attr('stroke', '\\t#00FF00')\\n                  .transition()\\n                  .duration(1000)\\n                  .remove());\\n          }\\n\\n        }\\n        timer += 1\\n        if (timer%100 >= 60) {\\n          timer += 100 - timer%100\\n        }\\n        if (timer >= 2400) {\\n          timer = 0;\\n        }\\n      }\\n\\n\\n      let time = setInterval(\\n        interval, intSpeed)\\n\\n      gMap.selectAll(\\\".airport\\\")\\n      .data(airports)\\n      .enter()\\n      .append(\\\"path\\\")\\n      .attr(\\\"class\\\", \\\"airport\\\")\\n      .attr(\\\"d\\\", path.pointRadius(1.5))\\n      // .attr(\\\"scale\\\", 100)\\n      .on(\\\"mouseover\\\", function(d){\\n        //\\n        d3.select(this)\\n        .attr(\\\"class\\\", \\\"activeAirport\\\")\\n        .attr(\\\"stroke\\\", \\\"blue\\\")\\n        .attr(\\\"stroke-width\\\", 0.5)\\n        .attr(\\\"fill\\\", \\\"red\\\")\\n        .attr(\\\"d\\\", path.pointRadius(5));\\n\\n        d3.select(\\\".map\\\")\\n        .append(\\\"text\\\")\\n        .attr(\\\"class\\\", \\\"countrydetails\\\")\\n        .text(\\n          \\\"Airport: \\\" + d.properties.name\\n        )\\n        d3.select(\\\".map\\\")\\n        .append(\\\"text\\\")\\n        .attr(\\\"class\\\", \\\"countrydetails\\\")\\n        .text(\\n          \\\"IATA: \\\" + d.properties.iata_code\\n        )\\n        //\\n      })\\n      // .on(\\\"click\\\", )\\n      .on(\\\"mouseout\\\", function(d){\\n        d3.selectAll(\\\"text.countrydetails\\\").remove()\\n\\n        d3.selectAll(\\\".activeAirport\\\")\\n        .attr(\\\"class\\\", \\\"airport\\\")\\n        .attr(\\\"d\\\", path.pointRadius(1.5));\\n\\n      });\\n\\n\\n      d3.select(\\\".map\\\")\\n      .append(\\\"input\\\")\\n      .attr(\\\"type\\\",\\\"button\\\")\\n      .attr(\\\"class\\\",\\\"pause\\\")\\n      .attr(\\\"value\\\",\\\"Pause\\\")\\n      .on(\\\"click\\\", function(){\\n          clearInterval(time)\\n      });\\n\\n      d3.select(\\\".map\\\")\\n      .append(\\\"input\\\")\\n      .attr(\\\"type\\\",\\\"button\\\")\\n      .attr(\\\"class\\\",\\\"play\\\")\\n      .attr(\\\"value\\\",\\\"Play\\\")\\n      .on(\\\"click\\\", function(){\\n        clearInterval(time)\\n        time = setInterval(interval, intSpeed)\\n      });\\n\\n      let speed = d3.select(\\\".map\\\")\\n      .append(\\\"text\\\")\\n      .attr(\\\"class\\\", \\\"speed\\\")\\n      .text(\\n        \\\"Speed: 1 hour = \\\" + (intSpeed/1000)*60 + \\\" seconds\\\"\\n      )\\n\\n      d3.select(\\\".map\\\")\\n      .append(\\\"input\\\")\\n      .attr(\\\"type\\\",\\\"button\\\")\\n      .attr(\\\"class\\\",\\\"play\\\")\\n      .attr(\\\"value\\\",\\\"X2\\\")\\n      .on(\\\"click\\\", function(){\\n        intSpeed = intSpeed/2\\n        d3.select(\\\".speed\\\").text(\\n          \\\"Speed: 1 hour = \\\" + (intSpeed/1000)*60 + \\\" seconds\\\"\\n        )\\n        clearInterval(time)\\n        time = setInterval(interval, intSpeed)\\n      });\\n\\n      d3.select(\\\".map\\\")\\n      .append(\\\"input\\\")\\n      .attr(\\\"type\\\",\\\"button\\\")\\n      .attr(\\\"class\\\",\\\"play\\\")\\n      .attr(\\\"value\\\",\\\"/2\\\")\\n      .on(\\\"click\\\", function(){\\n        intSpeed = intSpeed*2\\n        d3.select(\\\".speed\\\").text(\\n          \\\"Speed: 1 hour = \\\" + (intSpeed/1000)*60 + \\\" seconds\\\"\\n        )\\n        clearInterval(time)\\n        time = setInterval(interval, intSpeed)\\n      });\\n\\n    }\\n})();\\n\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/map_visualization.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}